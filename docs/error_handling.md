# Design Document: AetherScript Runtime Error Handling and Panic Subsystem

**Version:** 1.0
**Author:** Gemini
**Date:** July 24, 2025
**Status:** Proposed

## 1. Executive Summary

This document outlines the design and implementation plan for a robust error handling subsystem within the AetherScript runtime. The current runtime lacks mechanisms for gracefully handling panics, which can be triggered by contract violations or other unexpected runtime conditions. This results in abrupt program termination with a default Rust panic message, offering poor diagnostics for the end-user and failing to meet the language's goals of safety and verifiability.

The proposed solution introduces a comprehensive panic handling subsystem that will:
1.  **Intercept all runtime panics** using a global panic hook.
2.  **Capture detailed stack traces** at the moment a panic occurs.
3.  **Symbolicate and filter** these traces to provide a clean, human-readable call stack relevant to the AetherScript source code.
4.  **Present a structured and user-friendly error report** to the user, clearly stating the error and its origin.
5.  **Integrate seamlessly** with the AetherScript compiler to ensure this functionality is enabled in all compiled artifacts by default.

This system will significantly improve the developer experience, enhance the debuggability of AetherScript programs, and reinforce the language's core principles of explicitness and safety.

## 2. Background and Problem Statement

The AetherScript compiler and its associated design documents (`FINAL_DESIGN.md`, `user-guide.md`) describe a language with a strong emphasis on correctness, contracts, and verifiability. The compiler itself features a sophisticated, structured error reporting system (`src/error/`) designed for LLM consumption.

However, a critical gap exists at the boundary between compile-time checks and runtime execution. The compiler correctly generates code that panics when a contract is violated (e.g., `if !(precondition) { panic!(...) }`). While this enforces correctness, the user experience of such a panic is suboptimal. The program crashes with a raw Rust panic message, which is confusing for a user who only wrote or generated AetherScript code.

**Key Deficiencies:**
1.  **No Panic Interception:** The runtime does not use `std::panic::set_hook`, so all panics are unhandled.
2.  **No Stack Traces:** There is no mechanism to capture or display the call stack leading to the error.
3.  **Opaque Error Messages:** The default panic messages expose Rust implementation details and are not framed in the context of the AetherScript language.

## 3. Proposed Architecture and Design

The proposed solution is composed of three main components: a **Panic Hook** installed at runtime, a **Stack Trace Engine** for capturing and symbolizing call stacks, and a **Compiler Integration** step to enable the system.

### 3.1. Phase 1: The Custom Panic Handler

This phase focuses on intercepting the panic and extracting essential information.

#### 3.1.1. Runtime Initialization Function

A new, C-callable public function will be added to the runtime crate (`runtime/src/lib.rs`).

```rust
// In runtime/src/lib.rs

use std::panic::{self, PanicInfo};

#[no_mangle]
pub extern "C" fn aether_runtime_init() {
    panic::set_hook(Box::new(aether_panic_handler));
}

fn aether_panic_handler(panic_info: &PanicInfo) {
    // Detailed handling logic to be implemented here
    // (See section 3.3)
}
```

*   **`aether_runtime_init`**: This function's sole purpose is to install our custom panic handler using `std::panic::set_hook`. It is designed to be called once at the very beginning of an AetherScript program's execution.
*   **`aether_panic_handler`**: This function conforms to the signature required by `set_hook`. It will contain the logic for processing the panic, capturing the stack trace, and formatting the final error report.

#### 3.1.2. Panic Information Parsing

The `aether_panic_handler` will receive a `&PanicInfo` struct from the Rust standard library. It will extract the following critical information:
*   **Payload:** The panic message itself. This will be retrieved using `panic_info.payload().downcast_ref::<&str>()`. We will parse this string to identify the core error, especially for contract violations where the message is generated by the AetherScript compiler.
*   **Location:** The source code location of the panic, retrieved via `panic_info.location()`. This provides the file, line, and column number *within the Rust source of the runtime or the compiler-generated code*, which is a starting point for our more detailed trace.

### 3.2. Phase 2: Stack Trace Generation and Symbolization

This phase focuses on capturing and making sense of the call stack.

#### 3.2.1. Dependency Addition

The following dependency will be added to `runtime/Cargo.toml` to enable cross-platform backtrace functionality:

```toml
[dependencies]
backtrace = "0.3"
```

#### 3.2.2. Backtrace Capture and Symbolization

The `aether_panic_handler` will be extended:

```rust
// In runtime/src/lib.rs (inside aether_panic_handler)

// 1. Capture the backtrace
let backtrace = backtrace::Backtrace::new();

// 2. Resolve symbols (this can be slow, but is acceptable during a panic)
let mut trace_output = String::new();
let mut frames_processed = 0;

// backtrace::resolve is necessary to turn addresses into symbols
backtrace::resolve(backtrace, |frame| {
    // 3. Process each frame
    let ip = frame.ip();
    let symbol_address = frame.symbol_address();

    // 4. Resolve symbols in the frame
    backtrace::resolve_frame(frame, |symbol| {
        if let Some(name) = symbol.name() {
            // 5. Demangle and filter the symbol name
            let demangled_name = rustc_demangle::demangle(name.as_str()).to_string();

            // 6. Filter out irrelevant frames
            if should_display_frame(&demangled_name) {
                let filename = symbol.filename().map_or("<unknown>".to_string(), |p| p.display().to_string());
                let lineno = symbol.lineno().map_or(0, |l| l);

                // 7. Format the frame for the final report
                trace_output.push_str(&format!(
                    "  {:2}: {}\n      at {}:{}
",
                    frames_processed, demangled_name, filename, lineno
                ));
                frames_processed += 1;
            }
        }
    });
});
```

#### 3.2.3. Frame Filtering Logic

A crucial part of providing a clean trace is filtering out internal implementation details. The `should_display_frame` helper function will be implemented with the following logic:

*   It will receive the demangled function name as a string.
*   It will return `false` if the name contains substrings like:
    *   `std::`
    *   `core::`
    *   `backtrace::`
    *   `aether_runtime::panic_handler`
    *   `rust_begin_unwind`
*   This ensures the final stack trace focuses on functions originating from the AetherScript code and its direct runtime support, not the underlying language machinery.

### 3.3. Phase 3: User-Facing Error Report

The final step is to present the collected information in a clear, structured format.

#### 3.3.1. Formatted Output

The `aether_panic_handler` will print a formatted report to `stderr`. ANSI color codes will be used to improve readability.

**Example Output:**

```text
\x1b[91;1mError: AetherScript Runtime Panic\x1b[0m
\x1b[1mReason:\x1b[0m Precondition violation: 'denominator must not be zero'
\x1b[1mLocation:\x1b[0m src/stdlib/math.aether:15:8

\x1b[1mStack Trace (most recent call first):\x1b[0m
  \x1b[36m0:\x1b[0m \x1b[33mmath::safe_divide\x1b[0m
      at src/stdlib/math.aether:15
  \x1b[36m1:\x1b[0m \x1b[33mmain::calculate_value\x1b[0m
      at src/main.aether:25
  \x1b[36m2:\x1b[0m \x1b[33mmain\x1b[0m
      at src/main.aether:5
```

#### 3.3.2. Process Termination

After printing the report, the handler will ensure the program terminates cleanly but with a non-zero exit code to signal failure to calling scripts or systems.

```rust
// In runtime/src/lib.rs (end of aether_panic_handler)
std::process::exit(101); // 101 is the standard exit code for a Rust panic
```

### 3.4. Phase 4: Compiler Integration

The final piece is to ensure the runtime initialization is automatically included in every compiled AetherScript program.

1.  **LLVM IR Declaration:** In `src/llvm_backend/mod.rs`, the `aether_runtime_init` function will be declared so that LLVM knows its signature.

    ```rust
    // In src/llvm_backend/mod.rs, during module setup
    let init_fn_type = self.context.void_type().fn_type(&[], false);
    self.module.add_function("aether_runtime_init", init_fn_type, Some(Linkage::External));
    ```

2.  **Code Injection:** In the function responsible for generating the program's `main` function (e.g., `generate_main_wrapper`), we will use the `inkwell` IR builder to insert a call to `aether_runtime_init` at the very beginning of the function's entry block.

    ```rust
    // In src/llvm_backend/mod.rs, at the start of the generated main function
    let init_fn = self.module.get_function("aether_runtime_init").unwrap();
    self.builder.build_call(init_fn, &[], "call_runtime_init");
    ```

This ensures that the panic hook is set before any AetherScript code has a chance to execute, guaranteeing that all runtime panics will be caught.

## 4. Build and Debugging Considerations

*   **Debug Symbols:** For symbolization to work effectively, the final executable must be compiled with debug information. The build process should be configured to include debug symbols (`-g` flag to the linker) for debug builds. Release builds may have less detailed stack traces if symbols are stripped, and this trade-off should be documented.
*   **Performance:** Capturing a backtrace is a non-trivial operation. However, since it only occurs during a panic (a fatal event), the performance impact on normal program execution is zero. The cost is only paid when the program is already terminating.

## 5. Future Work

*   **Structured Panic Payloads:** The panic message is currently a simple string. We could define a custom struct to be used as the panic payload, containing more structured information about contract violations. This would make parsing the panic info more reliable.
*   **Integration with LLM Error Reporting:** The formatted stack trace could be captured and fed into the `StructuredError` system, providing even richer context to an LLM for debugging and auto-fixing runtime errors.
*   **AetherScript-level Panic Catching:** A future version of the language could expose a mechanism similar to Rust's `catch_unwind`, allowing AetherScript code to catch panics from specific function calls and handle them as recoverable errors.

This design provides a complete, end-to-end solution for robustly handling runtime errors in AetherScript, bringing its runtime safety and developer experience in line with its advanced compile-time capabilities.
