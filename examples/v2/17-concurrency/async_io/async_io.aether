module AsyncIO {
  // import std.io; // Disabled due to module loading error

  // Extern declarations
  @extern(library: "aether_runtime", symbol: "aether_print")
  func aether_print(text: String) -> Void;

  @extern(library: "aether_runtime", symbol: "print_int")
  func print_int(value: Int) -> Void;

  func print(text: String) -> Void {
    aether_print(text);
  }

  func println(text: String) -> Void {
    aether_print(text);
    aether_print("\n");
  }

  func slow_task(id: Int) -> Int {
    print("Starting task ");
    print_int(id);
    // print("\n"); already printed by print_int? No, print_int uses println in Rust.
    // Rust println! adds newline.
    
    // Simulate work
    let mut sum: Int = 0;
    let mut i: Int = 0;
    while ({i < 1000}) {
      sum = {sum + i};
      i = {i + 1};
    }

    print("Finished task ");
    print_int(id); 
    // print_int adds newline in Rust implementation
    return sum;
  }

  func main() -> Int {
    println("Starting async I/O example");

    // Concurrent block - tasks inside start concurrently
    concurrent {
      let res1 = slow_task(1);
      let res2 = slow_task(2);
      
      // For verification, we rely on side effects (printing)
    }

    println("Concurrent block finished");
    
    return 0;
  }
}