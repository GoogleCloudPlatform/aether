; FFI Demo - Demonstrating Foreign Function Interface
; Shows how to call C standard library functions from AetherScript

(DEFINE_MODULE
  (NAME "ffi_demo")
  (INTENT "Demonstrate FFI by calling C standard library functions")
  
  (CONTENT
    ; Declare external C functions
    (DECLARE_EXTERNAL_FUNCTION
      (NAME "c_strlen")
      (LIBRARY "libc")
      (SYMBOL "strlen")
      (RETURNS (TYPE SIZE_T))
      (ACCEPTS_PARAMETER (NAME "str") (TYPE (POINTER CHAR)) (PASSING BY_VALUE))
      (CALLING_CONVENTION C))
    
    (DECLARE_EXTERNAL_FUNCTION
      (NAME "c_malloc")
      (LIBRARY "libc")
      (SYMBOL "malloc")
      (RETURNS (TYPE (POINTER VOID))
        (OWNERSHIP CALLER_OWNED)
        (DEALLOCATOR "free"))
      (ACCEPTS_PARAMETER (NAME "size") (TYPE SIZE_T) (PASSING BY_VALUE))
      (CALLING_CONVENTION C))
    
    (DECLARE_EXTERNAL_FUNCTION
      (NAME "c_free")
      (LIBRARY "libc")
      (SYMBOL "free")
      (RETURNS (TYPE VOID))
      (ACCEPTS_PARAMETER (NAME "ptr") (TYPE (POINTER VOID)) (PASSING BY_VALUE))
      (CALLING_CONVENTION C))
    
    (DECLARE_EXTERNAL_FUNCTION
      (NAME "c_printf")
      (LIBRARY "libc")
      (SYMBOL "printf")
      (RETURNS (TYPE INT))
      (ACCEPTS_PARAMETER (NAME "format") (TYPE (POINTER CHAR)) (PASSING BY_VALUE))
      (CALLING_CONVENTION C)
      (VARIADIC TRUE))
    
    ; Math functions
    (DECLARE_EXTERNAL_FUNCTION
      (NAME "c_sqrt")
      (LIBRARY "libm")
      (SYMBOL "sqrt")
      (RETURNS (TYPE FLOAT64))
      (ACCEPTS_PARAMETER (NAME "x") (TYPE FLOAT64) (PASSING BY_VALUE))
      (CALLING_CONVENTION C))
    
    (DECLARE_EXTERNAL_FUNCTION
      (NAME "c_pow")
      (LIBRARY "libm")
      (SYMBOL "pow")
      (RETURNS (TYPE FLOAT64))
      (ACCEPTS_PARAMETER (NAME "base") (TYPE FLOAT64) (PASSING BY_VALUE))
      (ACCEPTS_PARAMETER (NAME "exponent") (TYPE FLOAT64) (PASSING BY_VALUE))
      (CALLING_CONVENTION C))
    
    ; Demonstrate string length calculation
    (DEFINE_FUNCTION
      (NAME "test_strlen")
      (INTENT "Test calling strlen from C standard library")
      (RETURNS (TYPE VOID))
      
      (BODY
        (DECLARE_VARIABLE (NAME "test_string") (TYPE STRING)
          (INITIAL_VALUE (STRING_LITERAL "Hello, FFI!")))
        
        ; Get C string pointer
        (DECLARE_VARIABLE (NAME "c_str") (TYPE (POINTER CHAR))
          (INITIAL_VALUE (CALL_FUNCTION "string_to_cstr"
            (ARGUMENTS (VARIABLE_REFERENCE "test_string")))))
        
        ; Call C strlen
        (DECLARE_VARIABLE (NAME "length") (TYPE SIZE_T)
          (INITIAL_VALUE (CALL_FUNCTION "c_strlen"
            (ARGUMENTS (VARIABLE_REFERENCE "c_str")))))
        
        ; Print result
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS 
            (STRING_LITERAL "String '%s' has length: %zu\n")
            (VARIABLE_REFERENCE "c_str")
            (VARIABLE_REFERENCE "length")))
        
        (RETURN_VOID)))
    
    ; Demonstrate memory allocation
    (DEFINE_FUNCTION
      (NAME "test_malloc_free")
      (INTENT "Test dynamic memory allocation via malloc/free")
      (RETURNS (TYPE VOID))
      
      (BODY
        (DECLARE_CONSTANT (NAME "BUFFER_SIZE") (TYPE SIZE_T) (VALUE (INTEGER_LITERAL 1024)))
        
        ; Allocate memory
        (DECLARE_VARIABLE (NAME "buffer") (TYPE (POINTER VOID))
          (INITIAL_VALUE (CALL_FUNCTION "c_malloc"
            (ARGUMENTS (VARIABLE_REFERENCE "BUFFER_SIZE")))))
        
        ; Check if allocation succeeded
        (IF_CONDITION (PREDICATE_NOT_EQUALS 
            (VARIABLE_REFERENCE "buffer") 
            (NULL_LITERAL))
          (THEN_EXECUTE
            (CALL_FUNCTION "c_printf"
              (ARGUMENTS (STRING_LITERAL "Successfully allocated %zu bytes\n")
                (VARIABLE_REFERENCE "BUFFER_SIZE")))
            
            ; Cast to byte pointer for use
            (DECLARE_VARIABLE (NAME "byte_buffer") (TYPE (POINTER BYTE))
              (INITIAL_VALUE (CAST_TO_TYPE 
                (VARIABLE_REFERENCE "buffer")
                (TYPE (POINTER BYTE)))))
            
            ; Use the buffer (write some data)
            (FOR_LOOP
              (INIT (DECLARE_VARIABLE (NAME "i") (TYPE INT) (INITIAL_VALUE (INTEGER_LITERAL 0))))
              (CONDITION (PREDICATE_LESS_THAN (VARIABLE_REFERENCE "i") (INTEGER_LITERAL 10)))
              (UPDATE (ASSIGN (TARGET "i") 
                (SOURCE (EXPRESSION_ADD (VARIABLE_REFERENCE "i") (INTEGER_LITERAL 1)))))
              (BODY
                (POINTER_STORE
                  (POINTER_ADD (VARIABLE_REFERENCE "byte_buffer") (VARIABLE_REFERENCE "i"))
                  (CAST_TO_TYPE (VARIABLE_REFERENCE "i") (TYPE BYTE)))))
            
            ; Free the memory
            (CALL_FUNCTION "c_free"
              (ARGUMENTS (VARIABLE_REFERENCE "buffer")))
            
            (CALL_FUNCTION "c_printf"
              (ARGUMENTS (STRING_LITERAL "Memory freed successfully\n"))))
          (ELSE_EXECUTE
            (CALL_FUNCTION "c_printf"
              (ARGUMENTS (STRING_LITERAL "Memory allocation failed!\n")))))
        
        (RETURN_VOID)))
    
    ; Demonstrate math functions
    (DEFINE_FUNCTION
      (NAME "test_math_functions")
      (INTENT "Test calling math functions from libm")
      (RETURNS (TYPE VOID))
      
      (BODY
        (DECLARE_VARIABLE (NAME "number") (TYPE FLOAT64)
          (INITIAL_VALUE (FLOAT_LITERAL 16.0)))
        
        ; Calculate square root
        (DECLARE_VARIABLE (NAME "sqrt_result") (TYPE FLOAT64)
          (INITIAL_VALUE (CALL_FUNCTION "c_sqrt"
            (ARGUMENTS (VARIABLE_REFERENCE "number")))))
        
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS 
            (STRING_LITERAL "sqrt(%.2f) = %.2f\n")
            (VARIABLE_REFERENCE "number")
            (VARIABLE_REFERENCE "sqrt_result")))
        
        ; Calculate power
        (DECLARE_VARIABLE (NAME "base") (TYPE FLOAT64)
          (INITIAL_VALUE (FLOAT_LITERAL 2.0)))
        (DECLARE_VARIABLE (NAME "exponent") (TYPE FLOAT64)
          (INITIAL_VALUE (FLOAT_LITERAL 8.0)))
        
        (DECLARE_VARIABLE (NAME "pow_result") (TYPE FLOAT64)
          (INITIAL_VALUE (CALL_FUNCTION "c_pow"
            (ARGUMENTS 
              (VARIABLE_REFERENCE "base")
              (VARIABLE_REFERENCE "exponent")))))
        
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS 
            (STRING_LITERAL "%.2f ^ %.2f = %.2f\n")
            (VARIABLE_REFERENCE "base")
            (VARIABLE_REFERENCE "exponent")
            (VARIABLE_REFERENCE "pow_result")))
        
        (RETURN_VOID)))
    
    ; AetherScript function that can be called from C
    (DEFINE_FUNCTION
      (NAME "aether_callback")
      (INTENT "Function that can be called back from C code")
      (EXPORT_AS C_FUNCTION (SYMBOL "aether_callback"))
      (ACCEPTS_PARAMETER (NAME "value") (TYPE INT))
      (RETURNS (TYPE INT))
      
      (SIDE_EFFECTS NONE)
      
      (BODY
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS 
            (STRING_LITERAL "AetherScript callback called with value: %d\n")
            (VARIABLE_REFERENCE "value")))
        
        ; Return value * 2
        (RETURN_VALUE (EXPRESSION_MULTIPLY 
          (VARIABLE_REFERENCE "value")
          (INTEGER_LITERAL 2)))))
    
    ; Main function
    (DEFINE_FUNCTION
      (NAME "main")
      (RETURNS (TYPE INT))
      
      (BODY
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS (STRING_LITERAL "=== AetherScript FFI Demo ===\n\n")))
        
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS (STRING_LITERAL "1. Testing string functions:\n")))
        (CALL_FUNCTION "test_strlen" (ARGUMENTS))
        
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS (STRING_LITERAL "\n2. Testing memory allocation:\n")))
        (CALL_FUNCTION "test_malloc_free" (ARGUMENTS))
        
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS (STRING_LITERAL "\n3. Testing math functions:\n")))
        (CALL_FUNCTION "test_math_functions" (ARGUMENTS))
        
        (CALL_FUNCTION "c_printf"
          (ARGUMENTS (STRING_LITERAL "\n=== FFI Demo Complete ===\n")))
        
        (RETURN_VALUE (INTEGER_LITERAL 0))))
  )
)