module VocabTest;

// ============================================================================
// Tests for Vocabulary Loader
// ============================================================================

// --- FFI: File I/O ---
@extern(library="aether_runtime", symbol="read_file_safe")
func read_file_safe(path: String, max_size: Int) -> String;

@extern(library="aether_runtime", symbol="write_file_safe")
func write_file_safe(path: String, content: String, append: Bool) -> Bool;

@extern(library="aether_runtime", symbol="aether_print")
func aether_print(s: String) -> Void;

// --- FFI: JSON ---
@extern(library="aether_runtime", symbol="parse_json")
func parse_json(json_string: String) -> String;

@extern(library="aether_runtime", symbol="json_get_field")
func json_get_field(json_value: String, field_name: String) -> String;

@extern(library="aether_runtime", symbol="json_object_keys")
func json_object_keys(json_value: String) -> String;

@extern(library="aether_runtime", symbol="json_array_length")
func json_array_length(json_array: String) -> Int;

@extern(library="aether_runtime", symbol="json_array_get")
func json_array_get(json_array: String, index: Int) -> String;

@extern(library="aether_runtime", symbol="json_to_string")
func json_to_string(json_value: String) -> String;

@extern(library="aether_runtime", symbol="to_integer")
func to_integer(json_value: String) -> Int;

// --- FFI: String operations ---
@extern(library="aether_runtime", symbol="string_length")
func string_length(s: String) -> Int;

@extern(library="aether_runtime", symbol="string_equals")
func string_equals(a: String, b: String) -> Bool;

@extern(library="aether_runtime", symbol="int_to_string")
func int_to_string(i: Int) -> String;

@extern(library="aether_runtime", symbol="aether_strdup")
func aether_strdup(s: String) -> String;

// --- FFI: String-Int Map (token -> ID) ---
// Using Int64 for pointer handles (64-bit on modern systems)

@extern(library="aether_runtime", symbol="string_int_map_new")
func string_int_map_new() -> Int64;

@extern(library="aether_runtime", symbol="string_int_map_insert")
func string_int_map_insert(map: Int64, key: String, value: Int) -> Bool;

@extern(library="aether_runtime", symbol="string_int_map_get")
func string_int_map_get(map: Int64, key: String) -> Int;

@extern(library="aether_runtime", symbol="string_int_map_contains")
func string_int_map_contains(map: Int64, key: String) -> Bool;

@extern(library="aether_runtime", symbol="string_int_map_size")
func string_int_map_size(map: Int64) -> Int;

@extern(library="aether_runtime", symbol="string_int_map_free")
func string_int_map_free(map: Int64) -> Void;

// --- FFI: Int-String Map (ID -> token) ---

@extern(library="aether_runtime", symbol="int_string_map_new")
func int_string_map_new() -> Int64;

@extern(library="aether_runtime", symbol="int_string_map_insert")
func int_string_map_insert(map: Int64, key: Int, value: String) -> Bool;

@extern(library="aether_runtime", symbol="int_string_map_get")
func int_string_map_get(map: Int64, key: Int) -> String;

@extern(library="aether_runtime", symbol="int_string_map_contains")
func int_string_map_contains(map: Int64, key: Int) -> Bool;

@extern(library="aether_runtime", symbol="int_string_map_size")
func int_string_map_size(map: Int64) -> Int;

@extern(library="aether_runtime", symbol="int_string_map_free")
func int_string_map_free(map: Int64) -> Void;

// ============================================================================
// Helper Functions
// ============================================================================

func println(s: String) -> Void {
    aether_print(s);
    aether_print("\n");
}

func print_int(label: String, val: Int) -> Void {
    aether_print(label);
    aether_print(": ");
    println(int_to_string(val));
}

// Returns 1 on success, 0 on failure
func assert_eq_int(actual: Int, expected: Int, msg: String) -> Int {
    if ({actual != expected}) {
        aether_print("FAIL: ");
        aether_print(msg);
        aether_print(" - expected ");
        aether_print(int_to_string(expected));
        aether_print(", got ");
        println(int_to_string(actual));
        return 0;
    }
    return 1;
}

// Returns 1 on success, 0 on failure
func assert_eq_str(actual: String, expected: String, msg: String) -> Int {
    if (!string_equals(actual, expected)) {
        aether_print("FAIL: ");
        aether_print(msg);
        aether_print(" - expected '");
        aether_print(expected);
        aether_print("', got '");
        aether_print(actual);
        println("'");
        return 0;
    }
    return 1;
}

// ============================================================================
// Test: Basic Map Operations
// ============================================================================

func test_string_int_map() -> Bool {
    println("=== Test: String-Int Map ===");

    let map = string_int_map_new();

    // Insert some values
    string_int_map_insert(map, "hello", 1);
    string_int_map_insert(map, "world", 2);
    string_int_map_insert(map, "<unk>", 0);

    // Check size
    let size = string_int_map_size(map);
    if (assert_eq_int(size, 3, "map size") == 0) {
        string_int_map_free(map);
        return false;
    }

    // Check get
    let hello_id = string_int_map_get(map, "hello");
    if (assert_eq_int(hello_id, 1, "hello ID") == 0) {
        string_int_map_free(map);
        return false;
    }

    let world_id = string_int_map_get(map, "world");
    if (assert_eq_int(world_id, 2, "world ID") == 0) {
        string_int_map_free(map);
        return false;
    }

    let unk_id = string_int_map_get(map, "<unk>");
    if (assert_eq_int(unk_id, 0, "<unk> ID") == 0) {
        string_int_map_free(map);
        return false;
    }

    // Check not found
    let missing = string_int_map_get(map, "notfound");
    if (assert_eq_int(missing, -1, "missing key returns -1") == 0) {
        string_int_map_free(map);
        return false;
    }

    // Check contains
    if (!string_int_map_contains(map, "hello")) {
        println("FAIL: contains should return true for 'hello'");
        string_int_map_free(map);
        return false;
    }

    if (string_int_map_contains(map, "notfound")) {
        println("FAIL: contains should return false for 'notfound'");
        string_int_map_free(map);
        return false;
    }

    string_int_map_free(map);
    println("PASS: String-Int Map");
    return true;
}

// ============================================================================
// Test: Int-String Map
// ============================================================================

func test_int_string_map() -> Bool {
    println("=== Test: Int-String Map ===");

    let map = int_string_map_new();

    // Insert some values
    int_string_map_insert(map, 0, "<unk>");
    int_string_map_insert(map, 1, "hello");
    int_string_map_insert(map, 2, "world");

    // Check size
    let size = int_string_map_size(map);
    if (assert_eq_int(size, 3, "map size") == 0) {
        int_string_map_free(map);
        return false;
    }

    // Check get
    let token0 = int_string_map_get(map, 0);
    if (assert_eq_str(token0, "<unk>", "token 0") == 0) {
        int_string_map_free(map);
        return false;
    }

    let token1 = int_string_map_get(map, 1);
    if (assert_eq_str(token1, "hello", "token 1") == 0) {
        int_string_map_free(map);
        return false;
    }

    let token2 = int_string_map_get(map, 2);
    if (assert_eq_str(token2, "world", "token 2") == 0) {
        int_string_map_free(map);
        return false;
    }

    // Check contains
    if (!int_string_map_contains(map, 0)) {
        println("FAIL: contains should return true for 0");
        int_string_map_free(map);
        return false;
    }

    if (int_string_map_contains(map, 999)) {
        println("FAIL: contains should return false for 999");
        int_string_map_free(map);
        return false;
    }

    int_string_map_free(map);
    println("PASS: Int-String Map");
    return true;
}

// ============================================================================
// Test: Load Vocabulary from JSON
// ============================================================================

func test_vocab_from_json() -> Bool {
    println("=== Test: Vocab from JSON ===");

    // Create test vocab JSON
    let vocab_json = "{\"hello\": 1, \"world\": 2, \"<unk>\": 0, \"the\": 3}";

    // Parse JSON
    let parsed = parse_json(vocab_json);
    if (string_length(parsed) == 0) {
        println("FAIL: Failed to parse vocab JSON");
        return false;
    }

    // Get keys
    let keys_json = json_object_keys(parsed);
    let key_count = json_array_length(keys_json);

    print_int("Key count", key_count);

    if ({key_count != 4}) {
        println("FAIL: Expected 4 keys");
        return false;
    }

    // Create maps and populate
    let token_to_id = string_int_map_new();
    let id_to_token = int_string_map_new();

    let mut i = 0;
    while ({i < key_count}) {
        // Get key from array
        let key_json = json_array_get(keys_json, i);
        let token = json_to_string(key_json);

        aether_print("Token ");
        aether_print(int_to_string(i));
        aether_print(": ");
        println(token);

        // Get ID value
        let reparsed = parse_json(vocab_json);
        let id_json = json_get_field(reparsed, token);
        let id = to_integer(id_json);

        aether_print("  ID: ");
        println(int_to_string(id));

        // Insert into maps
        let token_copy = aether_strdup(token);
        string_int_map_insert(token_to_id, token_copy, id);
        int_string_map_insert(id_to_token, id, token_copy);

        i = {i + 1};
    }

    // Verify forward lookup
    let hello_id = string_int_map_get(token_to_id, "hello");
    if (assert_eq_int(hello_id, 1, "hello ID lookup") == 0) {
        string_int_map_free(token_to_id);
        int_string_map_free(id_to_token);
        return false;
    }

    // Verify reverse lookup
    let token1 = int_string_map_get(id_to_token, 1);
    if (assert_eq_str(token1, "hello", "ID 1 reverse lookup") == 0) {
        string_int_map_free(token_to_id);
        int_string_map_free(id_to_token);
        return false;
    }

    // Verify vocab size
    let vocab_size = string_int_map_size(token_to_id);
    if (assert_eq_int(vocab_size, 4, "vocab size") == 0) {
        string_int_map_free(token_to_id);
        int_string_map_free(id_to_token);
        return false;
    }

    string_int_map_free(token_to_id);
    int_string_map_free(id_to_token);
    println("PASS: Vocab from JSON");
    return true;
}

// ============================================================================
// Test: Load Vocabulary from File
// ============================================================================

func test_vocab_from_file() -> Bool {
    println("=== Test: Vocab from File ===");

    // Write test vocab file
    let vocab_content = "{\"foo\": 10, \"bar\": 20, \"baz\": 30}";
    let write_ok = write_file_safe("test_vocab.json", vocab_content, false);

    if (!write_ok) {
        println("FAIL: Could not write test vocab file");
        return false;
    }

    // Read it back
    let content = read_file_safe("test_vocab.json", 1024);
    if (string_length(content) == 0) {
        println("FAIL: Could not read test vocab file");
        return false;
    }

    // Parse and verify
    let parsed = parse_json(content);
    let keys_json = json_object_keys(parsed);
    let key_count = json_array_length(keys_json);

    if (assert_eq_int(key_count, 3, "file vocab key count") == 0) {
        return false;
    }

    // Create map and load
    let token_to_id = string_int_map_new();

    let mut i = 0;
    while ({i < key_count}) {
        let key_json = json_array_get(keys_json, i);
        let token = json_to_string(key_json);
        let reparsed = parse_json(content);
        let id_json = json_get_field(reparsed, token);
        let id = to_integer(id_json);
        let token_copy = aether_strdup(token);
        string_int_map_insert(token_to_id, token_copy, id);
        i = {i + 1};
    }

    // Verify
    let foo_id = string_int_map_get(token_to_id, "foo");
    if (assert_eq_int(foo_id, 10, "foo ID") == 0) {
        string_int_map_free(token_to_id);
        return false;
    }

    let bar_id = string_int_map_get(token_to_id, "bar");
    if (assert_eq_int(bar_id, 20, "bar ID") == 0) {
        string_int_map_free(token_to_id);
        return false;
    }

    string_int_map_free(token_to_id);
    println("PASS: Vocab from File");
    return true;
}

// ============================================================================
// Main Test Runner
// ============================================================================

func main() -> Int {
    println("========================================");
    println("Vocabulary Loader Tests");
    println("========================================");
    println("");

    let mut passed = 0;
    let mut failed = 0;

    if (test_string_int_map()) {
        passed = {passed + 1};
    } else {
        failed = {failed + 1};
    }
    println("");

    if (test_int_string_map()) {
        passed = {passed + 1};
    } else {
        failed = {failed + 1};
    }
    println("");

    if (test_vocab_from_json()) {
        passed = {passed + 1};
    } else {
        failed = {failed + 1};
    }
    println("");

    if (test_vocab_from_file()) {
        passed = {passed + 1};
    } else {
        failed = {failed + 1};
    }
    println("");

    println("========================================");
    aether_print("Results: ");
    aether_print(int_to_string(passed));
    aether_print(" passed, ");
    aether_print(int_to_string(failed));
    println(" failed");
    println("========================================");

    if ({failed > 0}) {
        return 1;
    }
    return 0;
}
