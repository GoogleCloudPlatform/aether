module TestBpeTokenizer;

// ============================================================================
// Test BPE Tokenizer encode/decode
// ============================================================================

// FFI imports
@extern(library="aether_runtime", symbol="aether_print")
func print(s: String) -> Void;

@extern(library="aether_runtime", symbol="string_length")
func string_length(s: String) -> Int;

@extern(library="aether_runtime", symbol="substring")
func substring(s: String, start: Int, length: Int) -> String;

@extern(library="aether_runtime", symbol="string_equals")
func string_equals(a: String, b: String) -> Int;

@extern(library="aether_runtime", symbol="string_concat")
func string_concat(a: String, b: String) -> String;

@extern(library="aether_runtime", symbol="int_to_string")
func int_to_string(i: Int) -> String;

@extern(library="aether_runtime", symbol="write_file_safe")
func write_file_safe(path: String, content: String, append: Int) -> Int;

func write_file(path: String, content: String) -> Int {
    return write_file_safe(path, content, 0);
}

@extern(library="aether_runtime", symbol="read_file_safe")
func read_file(path: String, max_size: Int) -> String;

// String Array FFI - using Int64 to hold 64-bit pointers without ownership tracking
@extern(library="aether_runtime", symbol="string_array_create")
func string_array_create(capacity: Int) -> Int64;

@extern(library="aether_runtime", symbol="string_array_push")
func string_array_push(arr: Int64, value: String) -> Int64;

@extern(library="aether_runtime", symbol="string_array_get")
func string_array_get(arr: Int64, index: Int) -> String;

@extern(library="aether_runtime", symbol="string_array_length")
func string_array_length(arr: Int64) -> Int;

// JSON FFI
type JsonValue = String;

@extern(library="aether_runtime", symbol="parse_json")
func parse_json(json_string: String) -> JsonValue;

@extern(library="aether_runtime", symbol="json_get_field")
func json_get_field(json_value: JsonValue, field_name: String) -> JsonValue;

@extern(library="aether_runtime", symbol="to_integer")
func json_to_int(json_value: JsonValue) -> Int;

@extern(library="aether_runtime", symbol="json_object_keys")
func json_object_keys(json_value: JsonValue) -> JsonValue;

@extern(library="aether_runtime", symbol="json_array_length")
func json_array_length(json_value: JsonValue) -> Int;

@extern(library="aether_runtime", symbol="json_array_get")
func json_array_get(json_value: JsonValue, index: Int) -> JsonValue;

@extern(library="aether_runtime", symbol="json_to_string")
func json_to_string(json_value: JsonValue) -> String;

func println(s: String) -> Void {
    print(s);
    print("\n");
}

// ============================================================================
// Simple BPE implementation for testing
// ============================================================================

// Split text into characters (returns raw pointer as Int64)
func split_to_chars(text: String) -> Int64 {
    let mut chars = string_array_create(0);
    let len = string_length(text);

    let mut i = 0;
    while (i < len) {
        let c = substring(text, i, 1);
        chars = string_array_push(chars, c);
        i = i + 1;
    }

    return chars;
}

// Simple merge: find adjacent pair and merge them
func find_merge_index(tokens: Int64, first: String, second: String) -> Int {
    let num_tokens = string_array_length(tokens);
    if (num_tokens < 2) {
        return -1;
    }

    let mut i = 0;
    while (i < num_tokens - 1) {
        let t1 = string_array_get(tokens, i);
        let t2 = string_array_get(tokens, i + 1);
        if (string_equals(t1, first) != 0) {
            if (string_equals(t2, second) != 0) {
                return i;
            }
        }
        i = i + 1;
    }

    return -1;
}

// Apply a single merge
func apply_merge(tokens: Int64, merge_idx: Int) -> Int64 {
    let mut new_tokens = string_array_create(0);
    let num_tokens = string_array_length(tokens);

    let mut i = 0;
    while (i < num_tokens) {
        if (i == merge_idx) {
            let t1 = string_array_get(tokens, i);
            let t2 = string_array_get(tokens, i + 1);
            let merged = string_concat(t1, t2);
            new_tokens = string_array_push(new_tokens, merged);
            i = i + 2;
        } else {
            let t = string_array_get(tokens, i);
            new_tokens = string_array_push(new_tokens, t);
            i = i + 1;
        }
    }

    return new_tokens;
}

// Print array of strings
func print_tokens(label: String, tokens: Int64) -> Void {
    print(label);
    print(": [");
    let num = string_array_length(tokens);
    let mut i = 0;
    while (i < num) {
        if (i > 0) {
            print(", ");
        }
        print("'");
        print(string_array_get(tokens, i));
        print("'");
        i = i + 1;
    }
    println("]");
}

// ============================================================================
// Test: Basic character splitting
// ============================================================================
func test_split_chars() -> Bool {
    println("=== Test: Character splitting ===");

    let text = "hello";
    let chars = split_to_chars(text);

    print("Input: ");
    println(text);
    print_tokens("Chars", chars);

    let len = string_array_length(chars);
    if (len != 5) {
        print("FAIL: Expected 5 characters, got ");
        println(int_to_string(len));
        return false;
    }

    let c0 = string_array_get(chars, 0);
    if (string_equals(c0, "h") == 0) {
        print("FAIL: First char '");
        print(c0);
        println("' should be 'h'");
        return false;
    }

    let c4 = string_array_get(chars, 4);
    if (string_equals(c4, "o") == 0) {
        println("FAIL: Last char should be 'o'");
        return false;
    }

    println("PASS");
    return true;
}

// ============================================================================
// Test: Simple merge operation
// ============================================================================
func test_merge() -> Bool {
    println("=== Test: Merge operation ===");

    // Start with ['h', 'e', 'l', 'l', 'o']
    let tokens = split_to_chars("hello");
    print_tokens("Initial", tokens);

    // Find and merge 'l' + 'l' -> 'll'
    let idx = find_merge_index(tokens, "l", "l");
    print("Merge index for 'l'+'l': ");
    println(int_to_string(idx));

    if (idx < 0) {
        println("FAIL: Should find 'l'+'l' pair");
        return false;
    }

    let merged = apply_merge(tokens, idx);
    print_tokens("After merge", merged);

    let merged_len = string_array_length(merged);
    if (merged_len != 4) {
        print("FAIL: Expected 4 tokens after merge, got ");
        println(int_to_string(merged_len));
        return false;
    }

    // Should now be ['h', 'e', 'll', 'o']
    let t2 = string_array_get(merged, 2);
    if (string_equals(t2, "ll") == 0) {
        println("FAIL: Third token should be 'll'");
        return false;
    }

    println("PASS");
    return true;
}

// ============================================================================
// Test: JSON vocab parsing
// ============================================================================
func test_json_vocab() -> Bool {
    println("=== Test: JSON vocab parsing ===");

    // Create test vocab file
    let vocab_json = "{\"h\": 0, \"e\": 1, \"l\": 2, \"o\": 3, \"ll\": 4, \"he\": 5, \"hello\": 6}";
    let wrote = write_file("test_vocab.json", vocab_json);
    if (wrote == 0) {
        println("FAIL: Could not write vocab file");
        return false;
    }
    println("Wrote test_vocab.json");

    // Read and parse - reparse for each use to avoid ownership issues
    let content1 = read_file("test_vocab.json", 10000);
    println("Read content:");
    println(content1);

    let json1 = parse_json(read_file("test_vocab.json", 10000));
    println("Parsed JSON:");
    println(json1);

    // Get keys - reparse to get fresh json
    let json2 = parse_json(read_file("test_vocab.json", 10000));
    let keys_json = json_object_keys(json2);
    println("Keys (as JSON array):");
    println(keys_json);

    let num_keys = json_array_length(keys_json);
    print("Number of keys: ");
    println(int_to_string(num_keys));

    if (num_keys != 7) {
        println("FAIL: Expected 7 keys");
        return false;
    }

    // Get value for 'hello' - reparse again
    let json3 = parse_json(read_file("test_vocab.json", 10000));
    let hello_val_json = json_get_field(json3, "hello");
    let hello_id = json_to_int(hello_val_json);
    print("ID for 'hello': ");
    println(int_to_string(hello_id));

    if (hello_id != 6) {
        println("FAIL: 'hello' should have ID 6");
        return false;
    }

    println("PASS");
    return true;
}

// ============================================================================
// Test: BPE with merges
// ============================================================================
func test_bpe_encode() -> Bool {
    println("=== Test: BPE encoding ===");

    // Create test merges file
    // Merge order: l+l, h+e, he+llo (simplified)
    let merges_txt = "l l\nh e\nhe llo\n";
    let wrote = write_file("test_merges.txt", merges_txt);
    if (wrote == 0) {
        println("FAIL: Could not write merges file");
        return false;
    }
    println("Wrote test_merges.txt");

    // Start with "hello"
    let mut tokens = split_to_chars("hello");
    print_tokens("Initial", tokens);

    // Apply merge: l + l -> ll
    let idx1 = find_merge_index(tokens, "l", "l");
    if (idx1 >= 0) {
        tokens = apply_merge(tokens, idx1);
        print_tokens("After l+l merge", tokens);
    }

    // Apply merge: h + e -> he
    let idx2 = find_merge_index(tokens, "h", "e");
    if (idx2 >= 0) {
        tokens = apply_merge(tokens, idx2);
        print_tokens("After h+e merge", tokens);
    }

    // Final: should be ['he', 'll', 'o']
    let final_len = string_array_length(tokens);
    if (final_len != 3) {
        print("FAIL: Expected 3 tokens, got ");
        println(int_to_string(final_len));
        return false;
    }

    println("PASS");
    return true;
}

// ============================================================================
// Test: Round-trip encode/decode
// ============================================================================
func test_round_trip() -> Bool {
    println("=== Test: Round-trip ===");

    let original = "hello";
    let tokens = split_to_chars(original);

    // Apply merges
    let mut merged = tokens;
    let idx1 = find_merge_index(merged, "l", "l");
    if (idx1 >= 0) {
        merged = apply_merge(merged, idx1);
    }

    // "Decode" by joining
    let mut decoded = "";
    let num = string_array_length(merged);
    let mut i = 0;
    while (i < num) {
        let t = string_array_get(merged, i);
        decoded = string_concat(decoded, t);
        i = i + 1;
    }

    print("Original: ");
    println(original);
    print("Decoded: ");
    println(decoded);

    if (string_equals(original, decoded) == 0) {
        println("FAIL: Round-trip mismatch");
        return false;
    }

    println("PASS");
    return true;
}

// ============================================================================
// Test: Golden fixtures - deterministic expected outputs
// ============================================================================
func test_golden_fixtures() -> Bool {
    println("=== Test: Golden fixtures ===");

    // Test 1: Single character - should remain unchanged
    let chars1 = split_to_chars("a");
    if (string_array_length(chars1) != 1) {
        println("FAIL: 'a' should split into 1 char");
        return false;
    }
    if (string_equals(string_array_get(chars1, 0), "a") == 0) {
        println("FAIL: 'a' should be 'a'");
        return false;
    }

    // Test 2: Empty string
    let chars2 = split_to_chars("");
    if (string_array_length(chars2) != 0) {
        print("FAIL: Empty string should have 0 chars, got ");
        println(int_to_string(string_array_length(chars2)));
        return false;
    }

    // Test 3: Known merge sequence for "aab"
    // Starting: ['a', 'a', 'b']
    // After merging a+a: ['aa', 'b']
    let tokens3 = split_to_chars("aab");
    if (string_array_length(tokens3) != 3) {
        println("FAIL: 'aab' should have 3 chars initially");
        return false;
    }
    let idx3 = find_merge_index(tokens3, "a", "a");
    if (idx3 != 0) {
        print("FAIL: Expected merge index 0, got ");
        println(int_to_string(idx3));
        return false;
    }
    let merged3 = apply_merge(tokens3, idx3);
    if (string_array_length(merged3) != 2) {
        println("FAIL: After merge should have 2 tokens");
        return false;
    }
    if (string_equals(string_array_get(merged3, 0), "aa") == 0) {
        println("FAIL: First token should be 'aa'");
        return false;
    }
    if (string_equals(string_array_get(merged3, 1), "b") == 0) {
        println("FAIL: Second token should be 'b'");
        return false;
    }

    // Test 4: No merge available
    let tokens4 = split_to_chars("abc");
    let idx4 = find_merge_index(tokens4, "x", "y");
    if (idx4 != -1) {
        println("FAIL: Should not find 'x'+'y' in 'abc'");
        return false;
    }

    // Test 5: Multiple same-char pairs - "aaa" -> first merge at index 0
    let tokens5 = split_to_chars("aaa");
    let idx5 = find_merge_index(tokens5, "a", "a");
    if (idx5 != 0) {
        print("FAIL: First 'a'+'a' merge should be at index 0, got ");
        println(int_to_string(idx5));
        return false;
    }

    println("PASS");
    return true;
}

// ============================================================================
// Test: Unicode and multi-byte characters
// ============================================================================
func test_unicode_chars() -> Bool {
    println("=== Test: Unicode characters ===");

    // Test 1: Simple ASCII with spaces
    let text1 = "a b";
    let chars1 = split_to_chars(text1);
    print_tokens("'a b' splits to", chars1);
    if (string_array_length(chars1) != 3) {
        print("FAIL: 'a b' should have 3 chars, got ");
        println(int_to_string(string_array_length(chars1)));
        return false;
    }
    if (string_equals(string_array_get(chars1, 1), " ") == 0) {
        println("FAIL: Middle char should be space");
        return false;
    }

    // Test 2: Newline and tab characters
    let text2 = "a\nb";
    let chars2 = split_to_chars(text2);
    print_tokens("'a\\nb' splits to", chars2);
    if (string_array_length(chars2) != 3) {
        println("FAIL: 'a\\nb' should have 3 chars");
        return false;
    }

    // Test 3: Numbers and special characters
    let text3 = "123!@#";
    let chars3 = split_to_chars(text3);
    print_tokens("'123!@#' splits to", chars3);
    if (string_array_length(chars3) != 6) {
        println("FAIL: '123!@#' should have 6 chars");
        return false;
    }

    // Test 4: Mixed case
    let text4 = "AaBb";
    let chars4 = split_to_chars(text4);
    if (string_array_length(chars4) != 4) {
        println("FAIL: 'AaBb' should have 4 chars");
        return false;
    }
    if (string_equals(string_array_get(chars4, 0), "A") == 0) {
        println("FAIL: First char should be 'A'");
        return false;
    }
    if (string_equals(string_array_get(chars4, 1), "a") == 0) {
        println("FAIL: Second char should be 'a'");
        return false;
    }

    println("PASS");
    return true;
}

// ============================================================================
// Test: Comprehensive round-trip tests
// ============================================================================
func join_tokens(tokens: Int64) -> String {
    let mut result = "";
    let num = string_array_length(tokens);
    let mut i = 0;
    while (i < num) {
        let t = string_array_get(tokens, i);
        result = string_concat(result, t);
        i = i + 1;
    }
    return result;
}

func test_round_trip_comprehensive() -> Bool {
    println("=== Test: Comprehensive round-trip ===");

    // Test 1: Simple word
    let text1 = "test";
    let tokens1 = split_to_chars(text1);
    let result1 = join_tokens(tokens1);
    if (string_equals(text1, result1) == 0) {
        print("FAIL: Round-trip failed for '");
        print(text1);
        print("' -> got '");
        print(result1);
        println("'");
        return false;
    }
    println("  'test' round-trip OK");

    // Test 2: With spaces
    let text2 = "hello world";
    let tokens2 = split_to_chars(text2);
    let result2 = join_tokens(tokens2);
    if (string_equals(text2, result2) == 0) {
        println("FAIL: Round-trip failed for 'hello world'");
        return false;
    }
    println("  'hello world' round-trip OK");

    // Test 3: Numbers
    let text3 = "12345";
    let tokens3 = split_to_chars(text3);
    let result3 = join_tokens(tokens3);
    if (string_equals(text3, result3) == 0) {
        println("FAIL: Round-trip failed for '12345'");
        return false;
    }
    println("  '12345' round-trip OK");

    // Test 4: Mixed content
    let text4 = "abc123xyz";
    let tokens4 = split_to_chars(text4);
    let result4 = join_tokens(tokens4);
    if (string_equals(text4, result4) == 0) {
        println("FAIL: Round-trip failed for 'abc123xyz'");
        return false;
    }
    println("  'abc123xyz' round-trip OK");

    // Test 5: After merges - ensure content preserved
    let text5 = "aabb";
    let mut tokens5 = split_to_chars(text5);
    // Apply merge a+a
    let idx5a = find_merge_index(tokens5, "a", "a");
    if (idx5a >= 0) {
        tokens5 = apply_merge(tokens5, idx5a);
    }
    // Apply merge b+b
    let idx5b = find_merge_index(tokens5, "b", "b");
    if (idx5b >= 0) {
        tokens5 = apply_merge(tokens5, idx5b);
    }
    let result5 = join_tokens(tokens5);
    if (string_equals(text5, result5) == 0) {
        print("FAIL: Round-trip after merges failed for '");
        print(text5);
        print("' -> got '");
        print(result5);
        println("'");
        return false;
    }
    print_tokens("  'aabb' after merges", tokens5);
    println("  'aabb' round-trip after merges OK");

    // Test 6: Longer text
    let text6 = "The quick brown fox";
    let tokens6 = split_to_chars(text6);
    let result6 = join_tokens(tokens6);
    if (string_equals(text6, result6) == 0) {
        println("FAIL: Round-trip failed for longer text");
        return false;
    }
    print("  '");
    print(text6);
    println("' round-trip OK");

    println("PASS");
    return true;
}

// ============================================================================
// Test: Edge cases and boundary conditions
// ============================================================================
func test_edge_cases() -> Bool {
    println("=== Test: Edge cases ===");

    // Test 1: Single character string
    let tokens1 = split_to_chars("x");
    if (string_array_length(tokens1) != 1) {
        println("FAIL: Single char should produce 1 token");
        return false;
    }
    println("  Single char OK");

    // Test 2: Two character string
    let tokens2 = split_to_chars("xy");
    if (string_array_length(tokens2) != 2) {
        println("FAIL: Two char string should produce 2 tokens");
        return false;
    }
    println("  Two chars OK");

    // Test 3: Merge at end of token list
    let tokens3 = split_to_chars("xyaa");
    let idx3 = find_merge_index(tokens3, "a", "a");
    if (idx3 != 2) {
        print("FAIL: 'a'+'a' should be at index 2, got ");
        println(int_to_string(idx3));
        return false;
    }
    let merged3 = apply_merge(tokens3, idx3);
    if (string_array_length(merged3) != 3) {
        println("FAIL: After merge should have 3 tokens");
        return false;
    }
    if (string_equals(string_array_get(merged3, 2), "aa") == 0) {
        println("FAIL: Last token should be 'aa'");
        return false;
    }
    println("  Merge at end OK");

    // Test 4: Merge at beginning of token list
    let tokens4 = split_to_chars("aabb");
    let idx4 = find_merge_index(tokens4, "a", "a");
    if (idx4 != 0) {
        println("FAIL: 'a'+'a' should be at index 0");
        return false;
    }
    let merged4 = apply_merge(tokens4, idx4);
    if (string_equals(string_array_get(merged4, 0), "aa") == 0) {
        println("FAIL: First token should be 'aa'");
        return false;
    }
    println("  Merge at beginning OK");

    // Test 5: Multiple consecutive merges
    let mut tokens5 = split_to_chars("aaaa");
    // First merge: ['a','a','a','a'] -> ['aa','a','a']
    let idx5a = find_merge_index(tokens5, "a", "a");
    tokens5 = apply_merge(tokens5, idx5a);
    if (string_array_length(tokens5) != 3) {
        println("FAIL: First merge of 'aaaa' should give 3 tokens");
        return false;
    }
    // Second merge: ['aa','a','a'] -> ['aa','aa']
    let idx5b = find_merge_index(tokens5, "a", "a");
    if (idx5b >= 0) {
        tokens5 = apply_merge(tokens5, idx5b);
    }
    if (string_array_length(tokens5) != 2) {
        println("FAIL: Second merge should give 2 tokens");
        return false;
    }
    println("  Multiple consecutive merges OK");

    // Test 6: Non-existent merge pair
    let tokens6 = split_to_chars("abc");
    let idx6 = find_merge_index(tokens6, "z", "z");
    if (idx6 != -1) {
        println("FAIL: Should not find 'z'+'z' in 'abc'");
        return false;
    }
    println("  Non-existent merge pair OK");

    // Test 7: Repeated character string
    let tokens7 = split_to_chars("zzzzz");
    let len7 = string_array_length(tokens7);
    if (len7 != 5) {
        println("FAIL: 'zzzzz' should have 5 chars");
        return false;
    }
    // All characters should be 'z'
    let mut i = 0;
    while (i < len7) {
        if (string_equals(string_array_get(tokens7, i), "z") == 0) {
            println("FAIL: All chars should be 'z'");
            return false;
        }
        i = i + 1;
    }
    println("  Repeated character string OK");

    println("PASS");
    return true;
}

// ============================================================================
// Main
// ============================================================================
func main() -> Int {
    println("BPE Tokenizer Tests");
    println("==================");
    println("");

    let mut failures = 0;

    if (test_split_chars() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_merge() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_json_vocab() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_bpe_encode() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_round_trip() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_golden_fixtures() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_unicode_chars() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_round_trip_comprehensive() == false) {
        failures = failures + 1;
    }
    println("");

    if (test_edge_cases() == false) {
        failures = failures + 1;
    }
    println("");

    if (failures == 0) {
        println("==================");
        println("ALL TESTS PASSED");
        return 0;
    } else {
        println("==================");
        print("SOME TESTS FAILED (");
        print(int_to_string(failures));
        println(" failures)");
        return 1;
    }
}
